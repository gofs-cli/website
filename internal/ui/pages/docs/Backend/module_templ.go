// Code generated by templ - DO NOT EDIT.

// templ: version: v0.3.819
package backend

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

import . "github.com/gofs-cli/website/internal/ui/components"

func Module() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 1, "<div class=\"flex flex-col gap-y-2\"><h1 class=\"mb-4 text-4xl font-extrabold\">Adding a Backend Module</h1><h2 class=\"mt-2 text-2xl font-extrabold\">The internal/app folder</h2><p class=\"para\">Backend modules are located in the <code>/internal/app</code> folder.</p>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = CodeBlock(NoClipboard, `root
|--internal
|  |--app
|     |--[module 1]
|     |--[module 2]
|     |--[...]
`).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 2, "<p class=\"para\">Each backend module should have its own folder which should contain the exposed API and all the code for the module's  internal workings. </p><h2 class=\"mt-2 text-2xl font-extrabold\">Example</h2><p class=\"para\">Lets create a simple todo list app called mytodo. Start by initializing a new project.</p>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = Cmdline("gofs init github.com/myorg/mytodo mytodo").Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 3, "<p class=\"para\">Now lets create a backend module called <code>list</code> that will contain all the business logic and database logic for the todo list. Lets also say todo lists may not contain more than 20 items because that's just too much to do.</p><h3 class=\"text-2xl font-extrabold\">Create the list module folder</h3><p class=\"para\">Create a folder for the list module.</p>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = CodeBlock(NoClipboard, `mytodo
|--internal
|  |--app
|     |--list
`).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 4, "<h3 class=\"text-2xl font-extrabold\">Create the list api</h3><p class=\"para\">Create a new file <code>/internal/app/list/list.go</code> with the <code>List</code> struct and functions for creating a new todo list and adding items to the list. NB: This code is incomplete, you need to add the database code from  <a class=\"link\" href=\"/docs/backend/persistence\">Persisting data</a> before it will compile.")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = CodeBlock(NoClipboard, `mytodo
|--internal
|  |--app
|     |--list
|        |--list.go
`).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = CodeBlock(Clipboard, `package list

import (
	"github.com/google/uuid"
)

const MaxItems = 20

type List struct {
	ID    string
	Name  string
	Items []string
}

func NewList(name string) (*List, error) {
	l := &List{
		ID:   uuid.NewString(),
		Name: name,
	}

	// Save list to database
	if err != nil {
		return nil, err
	}

	return l, nil
}

func AddItem(listID string, item string) error {
	l, err := // Retrieve list from the database
	if err != nil {
		return err
	}

	// Check if the list is full
	if len(l.Items) >= MaxItems {
		return fmt.Errorf("Todo list is full")
	}

	l.Items = append(l.Items, item)

	// save to the database
	if err != nil {
		return err
	}

	return nil
}
`).Render(ctx, templ_7745c5c3_Buffer)
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		templ_7745c5c3_Err = templruntime.WriteString(templ_7745c5c3_Buffer, 5, "</p></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return nil
	})
}

var _ = templruntime.GeneratedTemplate
