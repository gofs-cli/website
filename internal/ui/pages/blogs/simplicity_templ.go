// Code generated by templ - DO NOT EDIT.

// templ: version: v0.2.778
package blogs

//lint:file-ignore SA4006 This context is only used if a nested component is present.

import "github.com/a-h/templ"
import templruntime "github.com/a-h/templ/runtime"

func Simplcity() templ.Component {
	return templruntime.GeneratedTemplate(func(templ_7745c5c3_Input templruntime.GeneratedComponentInput) (templ_7745c5c3_Err error) {
		templ_7745c5c3_W, ctx := templ_7745c5c3_Input.Writer, templ_7745c5c3_Input.Context
		if templ_7745c5c3_CtxErr := ctx.Err(); templ_7745c5c3_CtxErr != nil {
			return templ_7745c5c3_CtxErr
		}
		templ_7745c5c3_Buffer, templ_7745c5c3_IsBuffer := templruntime.GetBuffer(templ_7745c5c3_W)
		if !templ_7745c5c3_IsBuffer {
			defer func() {
				templ_7745c5c3_BufErr := templruntime.ReleaseBuffer(templ_7745c5c3_Buffer)
				if templ_7745c5c3_Err == nil {
					templ_7745c5c3_Err = templ_7745c5c3_BufErr
				}
			}()
		}
		ctx = templ.InitializeContext(ctx)
		templ_7745c5c3_Var1 := templ.GetChildren(ctx)
		if templ_7745c5c3_Var1 == nil {
			templ_7745c5c3_Var1 = templ.NopComponent
		}
		ctx = templ.ClearChildren(ctx)
		_, templ_7745c5c3_Err = templ_7745c5c3_Buffer.WriteString("<div class=\"flex flex-col gap-y-2 md:w-1/2\"><img class=\"h-96 w-full rounded-lg object-cover md:h-auto md:rounded-none\" src=\"/assets/img/blogs/simplicity.jpg\" alt=\"\"><h1 class=\"mb-4 text-4xl font-extrabold\">Keeping Things Simple</h1><h2 class=\"text-2xl font-extrabold\">Avoid trivial externals</h2><p class=\"para\">Before getting to the nub of this question, which is the definition of \"trivial\",  let me explain the idea. These days we have components and libraries for just about  everything. It may be tempting to use one of these for a UI component you don't want  to write, to handle a file manipulation that would be irritating to code, but what  happens when the authors of that component decide to stop supporting it, or even  worse they don't manage their vulnerabilities as well as you and then introduce a  supply chain attack into your software? Using externals leaves you with a codebase  that needs constant upgrading. However, it also doesn't make sense to write everything  yourself. You don't write your own operating system or database software. But where  do you draw the line? We consider this to be a question of judgement but as a rule  of thumb, if you can write the features you need from a dependency in 1-2 weeks,  then you should consider it trivial and you really shouldn't be using it.</p><h2 class=\"text-2xl font-extrabold\">Internal structure and code</h2><p class=\"para\">Write code to meet your known requirements. Attempting to cater for future scenarios  that are uncertain and subject to change anyway will lead a team to over-engineer software,  making it more complex, slower to extend and usually more brittle. This problem can be  exacerbated by senior engineers who are trying do the right thing to avoid problems they  may have experienced on another codebase, but instead end up introducing unnecessary  complexity. We love Eric Lau's  <a href=\"https://github.com/eric19960304/hello-world-overengineering\">hello world</a> that uses a complex class hierarchy and the factory design pattern to decouple everything  from everything else and bring it back together to print \"hello world\".</p><h2 class=\"text-2xl font-extrabold\">Functionality of the system</h2><p class=\"para\">Famously 80% of features in software systems are rarely or never used, or even worse  they can have a negative effect. For example at Google and Bing 80%-90% of features  have a negative impact on metrics. Business users and even some product owners will  ask for features, describing the final solution, instead of helping developers  understand the actual problem and work together to find a simple solution. Developers  should always make an effort to understand and challenge the business problem before  accepting the feature request.</p></div>")
		if templ_7745c5c3_Err != nil {
			return templ_7745c5c3_Err
		}
		return templ_7745c5c3_Err
	})
}

var _ = templruntime.GeneratedTemplate
